import { PythonExportPayload } from './types';

export function generatePython({ strategy, resolved }: PythonExportPayload): string {
  // Minimal but clean generator; extend as needed.
  const s = resolved.strategy;
  const indList = resolved.indicators.map(i => i.id);

  return `# Bot Forge export (long-only by default, no Heikin-Ashi)
# Indicators in use: ${indList.join(', ')}

import math

# --- Indicator stubs (fill with your actual implementations) ---
def ema(series, period): ...
def sma(series, period): ...
def rsi(series, length): ...
def macd(series, fast, slow, signal): ...
def atr(high, low, close, length): ...
def bb(series, length, mult): ...
def stoch(high, low, close, k, d, smooth): ...
def vwap(high, low, close, volume): ...
def obv(close, volume): ...
def cci(high, low, close, length): ...
def adx(high, low, close, length): ...
def keltner(close, length, atr_len, mult): ...
def donchian(high, low, upper_len, lower_len): ...
def ichimoku(high, low, close, tenkan, kijun, span_b): ...
def supertrend(high, low, close, atr_len, mult): ...
def mfi(high, low, close, volume, length): ...
def roc(series, length): ...
def williams_r(high, low, close, length): ...
def psar(high, low, af_start, af_step, af_max): ...
def vol_ma(volume, period): ...

# --- Strategy registry pattern ---
def run_${s.id}(data, params):
    # data: dict of arrays {open, high, low, close, volume}
    # params: indicator params merged from UI selection
    # long-only default
    # TODO: apply rules exactly as configured by the UI
    return []

strategy_registry = {
    "${s.id}": run_${s.id},
}
`;
}

export async function downloadPython(payload: PythonExportPayload) {
  const pythonCode = generatePython(payload);
  const blob = new Blob([pythonCode], { type: 'text/x-python' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = 'bot_forge_strategy.py';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}